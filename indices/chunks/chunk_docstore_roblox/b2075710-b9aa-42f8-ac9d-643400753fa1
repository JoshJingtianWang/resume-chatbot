{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"page_content": "Aggregated data handling:\n\nAlthough the original SliceFinder is intended for raw data (i.e. each row is transactional level), I have modified it to handle both raw and aggregated data readily. For example, in the revenue use case that we previously mentioned (\ud835\udc5f\ud835\udc52\ud835\udc63\ud835\udc52\ud835\udc5b\ud835\udc62\ud835\udc52 = \ud835\udc40\ud835\udc34\ud835\udc48 \u2217 \ud835\udc37\ud835\udc34\ud835\udc48/\ud835\udc40\ud835\udc34\ud835\udc48 \u2217 \ud835\udc5f\ud835\udc52\ud835\udc63\ud835\udc52\ud835\udc5b\ud835\udc62\ud835\udc52/\ud835\udc37\ud835\udc34\ud835\udc48), for SliceFinder to process aggregated data, all subfactor columns in the data tables are required to be summ-able. In the aggregated synthetic data table below, we can see that \u201cMAU\u201d, \u201cDAU\u201d,\n\nand \u201crevenue\u201d columns are summ-able. SliceFinder will then find slices from the most coarse aggregation level to the provided aggregation level (most granular).\n\nCountry\n\nGender\n\nDevice\n\nMAU\n\nDAU\n\nrevenue\n\nUS\n\nM\n\nAndroid\n\n5 million\n\n1.5 million\n\n$3 million\n\nUS\n\nF\n\nAndroid\n\n4.5 million\n\n2 million\n\n$2.5 million\n\n\u2026\n\n\u2026\n\n\u2026\n\nOne caveat of this approach is that dimensions such as DAU and MAU are only \u201cassumed summ-able\u201d. In rare cases, a player may use multiple devices, and land in multiple rows as a result. In those cases, the rows may overlap each other, and the user should use discretion when proceeding with SliceFinder. Same with percentile metrics, SliceFinder cannot conduct effect size and significance testing to filter for interesting slices when dealing with aggregated data. We recommend setting the degree parameter to be lower than 3 in this situation.\n\nData Quality Explainer, an extension of SliceFinder", "metadata": {"source": "./documents/Roblox/Project 1_ SliceFinder Final Writeup.pdf"}, "type": "Document"}}