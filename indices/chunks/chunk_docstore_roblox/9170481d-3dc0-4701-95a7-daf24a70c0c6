{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"page_content": "Figure 3. Top panel, crash rate by free memory. Bottom panel, crash rate by passmark score (a benchmark score of devices. Higher passmark scores mean more powerful devices). The size of each bubble is the size of the slice. We can see that the lower the free memory or the passmark score, the higher the inferred crash rate.\n\nSliceFinder returned \u201cdevice: Android\u201d, \u201cfree_os_mem: < 0.314\u201d and \u201cpassmark_score: < 1344\u201d. While the snapshot results make sense (Figure 3.), they are well-understood knowledge and do not provide any\n\nnew and actionable information for the engineering team. On the other hand, if we use SliceFinder as a monitoring tool and root-cause the target metric changes, SliceFinder may be able to surface top moving slices that provide more useful insights. Therefore, I implement time series handling, along with many other powerful new features to the original SliceFinder.\n\nAdded features (abridged due to sensitivity):\n\nGreatly improved parallel processing:\n\nFigure 4. Runtime analysis of SliceFinder vs number of workers. Blue line is the original implementation of multithreading, orange is the improved multithreading.\n\nVisualization: I implemented interactive visualization for SliceFinder\u2019s snapshot task results (Figure 5). In the bubble plot, the size of the bubble corresponds to the size of the slice and the color corresponds to the type of the slice filtering condition. Hover over to see the statistics of the slice (effect size, p value, average metric, etc.)\n\nFigure 5. Visualization of crash rate snapshot RCA result. Download and open in the browser to interact with it.", "metadata": {"source": "./documents/Roblox/Josh Wang Internship at Roblox Report.pdf"}, "type": "Document"}}